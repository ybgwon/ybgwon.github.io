<!doctype html><html lang=en><head><title>YB Gwon's ...</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="YB Gwon's blog for creative and technical writing."><meta name=author content="[Yong-Beom Gwon]"><meta name=generator content="Hugo 0.60.1"><meta property="og:title" content="Posts"><meta property="og:description" content="YB Gwon's blog for creative and technical writing."><meta property="og:type" content="website"><meta property="og:url" content="/posts/"><meta property="og:updated_time" content="2019-12-05T19:37:00+09:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="YB Gwon's blog for creative and technical writing."><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css><script src=https://kit.fontawesome.com/b76b73e8e8.js crossorigin=anonymous></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans+KR|Roboto|Ruda"><link rel=stylesheet type=text/css href=/css/styles.css><link rel=stylesheet href=/css/style.css></head><body><div id=container><header><h1><a href=/>YB Gwon's &mldr;</a></h1><ul id=social-media><li><a href=https://github.com/ybgwon title=GitHub><i class="fab fa-github fa-lg"></i></a></li></ul><p><em>Personal Blog for creative and technical writing</em></p></header><nav><ul><li><a href=/posts/><i class="fa-li fa fa-lg"></i><span>Posts</span></a></li><li><a href=/about/><i class="fa-li fa fa-lg"></i><span>About Hugo</span></a></li></ul></nav><main><article><h1>kernel-study-2019-11-23</h1><aside><ul><li><time class=post-date datetime=2019-12-05T19:37:00+09:00>Dec 5, 2019</time></li><li>2 minutes read</li></ul></aside><p>boot_cpu_init 함수 분석. 첫번째 processor 를 활성화한다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> __init <span style=color:#a6e22e>boot_cpu_init</span>(<span style=color:#66d9ef>void</span>)
{
      <span style=color:#66d9ef>int</span> cpu <span style=color:#f92672>=</span> smp_processor_id();

      <span style=color:#75715e>/* Mark the boot cpu &#34;present&#34;, &#34;online&#34; etc for SMP and UP case */</span>
      set_cpu_online(cpu, true);
      set_cpu_active(cpu, true);
      set_cpu_present(cpu, true);
      set_cpu_possible(cpu, true);

<span style=color:#75715e>#</span><span style=color:#75715e>ifdef CONFIG_SMP</span><span style=color:#75715e>
</span><span style=color:#75715e></span>      __boot_cpu_id <span style=color:#f92672>=</span> cpu;
<span style=color:#75715e>#</span><span style=color:#75715e>endif</span><span style=color:#75715e>
</span><span style=color:#75715e></span>}
</code></pre></div><h2 id=smp-processor-id>smp_processor_id</h2><p>percpu 변수 cpu_number 값을 매크로 함수를 통해 읽어 온다</p><h3 id=cpu-number>cpu_number</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#</span><span style=color:#75715e>define raw_smp_processor_id() (*raw_cpu_ptr(&amp;cpu_number))</span><span style=color:#75715e>
</span></code></pre></div><p>raw_cpu_ptr 매크로 함수로 넘어가는 cpu_number 파라메터는아래와 같이 정의돼 있다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>DECLARE_PER_CPU_READ_MOSTLY(<span style=color:#66d9ef>int</span>, cpu_number);
</code></pre></div><p>결국 아래와 같이 변환된다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>extern</span> __attribute__((section(.data..percpu..read_mostly)) <span style=color:#66d9ef>int</span> cpu_number
</code></pre></div><h4 id=typeof><code>__typeof__</code></h4><p>변수 타입 반환 gcc 확장기능</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> i;
__typeof__(i) j;
<span style=color:#75715e>/* above equals int j */</span>
</code></pre></div><h3 id=raw-cpu-ptr>raw_cpu_ptr</h3><p>매크로 함수</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#</span><span style=color:#75715e>define raw_cpu_ptr(ptr)						\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>({									\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>      __verify_pcpu_ptr(ptr);						\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>      arch_raw_cpu_ptr(ptr);						\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>})</span><span style=color:#75715e>
</span></code></pre></div><h4 id=verify-pcpu-ptr--ptr>__verify_pcpu_ptr(ptr)</h4><p>__CHECKER__(정적분석도구) 가 define 되어 있을때 ptr이 percpu 영역에 있는지 검사</p><h4 id=arch-raw-cpu-ptr--ptr>arch_raw_cpu_ptr(ptr);</h4><p>ptr 과 __my_cpu_offset를 매개 변수로 RELOC_HIDE 호출</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#</span><span style=color:#75715e>define SHIFT_PERCPU_PTR(__p, __offset)									\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>      RELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))</span><span style=color:#75715e>
</span></code></pre></div><ul><li><p>RELOC_HIDE - 컴파일러 에러 방지 위해 사용하는 매크로 함수.<br><a href=http://studyfoss.egloos.com/5374731>http://studyfoss.egloos.com/5374731</a></p></li><li><p>return 값</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#</span><span style=color:#75715e>define RELOC_HIDE(ptr, off)        \</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>({									\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>    unsigned long __ptr;						\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>    __asm__ (&#34;&#34; : &#34;=r&#34;(__ptr) : &#34;0&#34;(ptr));				\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>    (typeof(ptr)) (__ptr + (off));					\</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#75715e>})</span><span style=color:#75715e>
</span></code></pre></div><p>마지막 __ptr + (off) return. 마지막 부분은 선언만 하고 있으나<br>gcc 확장기능에 의해 return 된다<br>gcc 확장기능 - compound statement(중괄호로 둘러싼 여러 statement)를<br>expression으로 해석하는 기능.<br>최종 결과는 아래와 같다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>(<span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>) (<span style=color:#f92672>&amp;</span>cpu_number  <span style=color:#f92672>+</span> tpidr_el1 value)       
</code></pre></div></li></ul><h2 id=set-cpu-online--set-cpu-active-set-cpu-present-set-cpu-possible>set_cpu_online(set_cpu_active,set_cpu_present,set_cpu_possible)</h2><p>struct cpumask 형식의 __cpu_online_mask<br>구조체의 멤버인 bits 배열에 현재 cpu 의 bit를 set 한다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> cpumask __cpu_online_mask { <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> bits[<span style=color:#ae81ff>4</span>]; };
cpumask_set_cpu(cpu, <span style=color:#f92672>&amp;</span>__cpu_online_mask);
<span style=color:#75715e>/*
</span><span style=color:#75715e> * cpu 가 129 라면 129/64 0~63, 64~127, 128,129... 순이 되고
</span><span style=color:#75715e> * 3번째 인덱스의 2번째 비트를 1로 set하게 되므로 bits[2]
</span><span style=color:#75715e> * 의 값이 2 가 된다. bits[2] 이 원래 0 이었을 경우
</span><span style=color:#75715e> */</span>
bits[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span><span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</code></pre></div><h3 id=set-bit--cpumask-checkcpu--cpumask-bits--dstp>set_bit(cpumask_check(cpu), cpumask_bits(dstp))</h3><p>setbit 함수의 경우 현재 cpu 변수와 cpumask 구조체의 포인터를가지고 결국 bits 배열에 cpu 변수를 set 하는 atomic asm 명령어를호출하게 된다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> arch_atomic64_<span style=color:#960050;background-color:#1e0010>#</span><span style=color:#960050;background-color:#1e0010>#</span>op(<span style=color:#66d9ef>long</span> i, atomic64_t <span style=color:#f92672>*</span>v)		\
{									\
      <span style=color:#66d9ef>register</span> <span style=color:#66d9ef>long</span> x0 <span style=color:#66d9ef>asm</span> (<span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>x0</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>=</span> i;				\
      <span style=color:#66d9ef>register</span> atomic64_t <span style=color:#f92672>*</span>x1 <span style=color:#a6e22e>asm</span> (<span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>x1</span><span style=color:#e6db74>&#34;</span>) <span style=color:#f92672>=</span> v;				\
								      \
      <span style=color:#66d9ef>asm</span> <span style=color:#a6e22e>volatile</span>(ARM64_LSE_ATOMIC_INSN(__LL_SC_ATOMIC64(op),	\
<span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>	</span><span style=color:#e6db74>&#34;</span> <span style=color:#960050;background-color:#1e0010>#</span>asm_op <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>	%[i], %[v]</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)					\
      <span style=color:#f92672>:</span> [i] <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>+r</span><span style=color:#e6db74>&#34;</span> (x0), [v] <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>+Q</span><span style=color:#e6db74>&#34;</span> (v<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>counter)				\
      <span style=color:#f92672>:</span> <span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;</span> (x1)							\
      <span style=color:#f92672>:</span> __LL_SC_CLOBBERS);						\
}

ATOMIC64_OP(or, stset)
</code></pre></div><p>위 inline asm 명령은 lse 기능(ARMV8.1이상)을 cpu 에서지원하느냐에 따라 LL/SC 방식이나 CAS 구현방식을 사용하는 LSE 중에<br>ALTERNATIVE 매크로를 이용하여 atomic 명령을 선택하게 된다.</p><figure><a href=/images/stset.png><img src=/images/stset.png></a></figure><h3 id=atomic-operation>Atomic Operation</h3><ol><li>ARMv5 이하모두 UP(Uni Processor) 시스템용으로만 구현되어 있어 인터럽트를 막는 것으로 구현</li><li>ARMv6, ARMv7<br>UP로 커널을 빌드하여 사용 시 인터럽트를 막는 것으로 구현<br>SMP로 커널을 빌드하여 사용 시 LL/SC 방식으로 구현</li><li>ARMv8<br>UP/SMP 가리지 않고 LL/SC 방식으로 구현</li><li>ARMv8.1~<br>UP/SMP 가리지 않고 CAS 방식(LSE atomic 명령 채용)으로 구현</li></ol><h3 id=참조>참조</h3><p><a href=http://jake.dothome.co.kr/atomic/>http://jake.dothome.co.kr/atomic/</a></p></article><section class=post-nav><ul><li><a href=/posts/kernel-study-2019-11-16/><i class="fa fa-chevron-circle-left"></i>Kernel-Study-2019-11-16</a></li></ul></section><section class=comments-block><button id=show-comments style=display:none><i class="fa fa-comments"></i></button></section><section id=disqus_thread></section><script>(function(){if(window.location.hostname=="localhost")
return;var disqus_loaded=false;var disqus_shortname='ybgwon';var disqus_button=document.getElementById("show-comments");disqus_button.style.display="";disqus_button.addEventListener("click",disqus,false);function disqus(){if(!disqus_loaded){disqus_loaded=true;var e=document.createElement("script");e.type="text/javascript";e.async=true;e.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e);document.getElementById("show-comments").style.display="none";}}
var hash=window.location.hash.substr(1);if(hash.length>8){if(hash.substring(0,8)=="comment-"){disqus();}}
if(/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)){disqus();}})();</script></main><footer><h6>Copyright © 2019 - ybgwon |
Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> |
<a href=/index.xml>Subscribe</a></h6></footer></div><script src=/js/scripts.js></script></body></html>